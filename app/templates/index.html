{% extends "base.html" %}

{% block content %}
<section class="query-section" aria-labelledby="query-helper-heading">
  <h2 id="query-helper-heading">Build export queries for a set of Accounts</h2>
  <p>
    Paste one or more Account IDs and we will generate SOQL snippets that you can run in Salesforce to
    produce CSV extracts for every supported object.
  </p>
  <form id="query-generator-form" class="query-form">
    <label for="account-ids">Account IDs</label>
    <textarea
      id="account-ids"
      name="account_ids"
      rows="4"
      placeholder="001XXXXXXXXXXXX\n001YYYYYYYYYYYY\n001ZZZZZZZZZZZZ"
      aria-describedby="query-helper-hint"
    ></textarea>
    <p id="query-helper-hint" class="form-hint">
      Separate Account IDs by commas, spaces, or new lines. At least one ID is required to build the queries.
    </p>
    <div class="form-actions">
      <button type="submit" class="primary">Generate queries</button>
      <button type="reset" class="secondary" id="clear-queries">Clear</button>
    </div>
  </form>
  <div id="query-results" class="query-results" aria-live="polite"></div>
</section>

<section class="steps" aria-label="Guided steps">
  <button class="step-button active" data-target="import-step">1. Import CSV files</button>
  <button class="step-button" data-target="alerts-step">2. Review alerts</button>
  <button class="step-button" data-target="alert-config-step">3. Configure alert logic</button>
  <button class="step-button" data-target="alert-guide-step">4. Alert authoring guide</button>
</section>

<section id="import-step" class="panel active" aria-labelledby="import-heading">
  <h2 id="import-heading">Step 1 &mdash; Import Salesforce extracts</h2>
  <p>
    Provide the CSV exports for each Salesforce object. Every upload refreshes the in-memory data
    store and rebuilds the relationships between Accounts, Contacts, Individuals, Contact Points, and AccountContactRelations.
  </p>
  <form id="import-form" enctype="multipart/form-data">
    <div class="form-grid">
      {% for entity in entities %}
      <label class="file-input">
        <span class="label-text">{{ entity.replace('_', ' ').title() }}</span>
        <input type="file" name="{{ entity }}" accept=".csv" />
      </label>
      {% endfor %}
    </div>
    <div class="form-actions">
      <button type="submit" class="primary">Upload and rebuild</button>
      <button type="reset" class="secondary">Clear selections</button>
    </div>
  </form>
  <div id="import-feedback" role="status" aria-live="polite" class="feedback"></div>
</section>

<section id="alerts-step" class="panel" aria-labelledby="alerts-heading">
  <h2 id="alerts-heading">Step 2 &mdash; Investigate generated alerts</h2>
  <p>
    After the import completes, use this dashboard to understand potential data quality issues.
    The default alerts focus on duplicate roles, missing roles, conflicting roles, and duplicate contact points.
  </p>
  <div class="alert-controls">
    <button id="refresh-alerts" class="primary">Refresh alerts</button>
    <span id="alert-count" class="badge" aria-live="polite"></span>
  </div>
  <div class="alert-tabs" data-component="alert-tabs">
    <div class="alert-tablist" role="tablist" aria-label="Alert views">
      <button
        type="button"
        class="alert-tab active"
        role="tab"
        id="alert-tab-trigger-details"
        aria-selected="true"
        aria-controls="alert-tab-panel-details"
        data-alert-tab="details"
      >
        Details
      </button>
      <button
        type="button"
        class="alert-tab"
        role="tab"
        id="alert-tab-trigger-summary"
        aria-selected="false"
        aria-controls="alert-tab-panel-summary"
        data-alert-tab="summary"
      >
        Summary
      </button>
    </div>
    <div
      id="alert-tab-panel-details"
      class="alert-tab-panel"
      role="tabpanel"
      aria-labelledby="alert-tab-trigger-details"
    >
      <ul id="alert-list" class="alert-list" aria-live="polite"></ul>
    </div>
    <div
      id="alert-tab-panel-summary"
      class="alert-tab-panel"
      role="tabpanel"
      aria-labelledby="alert-tab-trigger-summary"
      hidden
    >
      <div class="alert-summary" id="alert-summary">
        <div class="alert-summary-controls">
          <button id="download-alerts-csv" class="secondary" type="button" disabled>
            Download CSV
          </button>
        </div>
        <p id="alert-summary-empty" class="alert-summary-empty">No alerts generated yet.</p>
        <table id="alert-summary-table" class="alert-summary-table" hidden>
          <thead>
            <tr>
              <th scope="col">Alert type</th>
              <th scope="col">Description</th>
              <th scope="col">Triggered</th>
            </tr>
          </thead>
          <tbody id="alert-summary-body"></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<section id="alert-config-step" class="panel" aria-labelledby="alert-config-heading">
  <h2 id="alert-config-heading">Step 3 &mdash; Configure alert logic</h2>
  <p>
    Review the active alerts, inspect the Python logic that powers them, and create new checks tailored to your
    organisation. Saving a change immediately updates the alert engine.
  </p>
  <div class="alert-config-layout">
    <div class="alert-config-list" aria-labelledby="alert-list-heading">
      <div class="alert-config-list-header">
        <h3 id="alert-list-heading">Available alerts</h3>
        <button id="add-alert-definition" class="secondary" type="button">Add alert</button>
      </div>
      <ul id="alert-definition-list" class="alert-definition-list" aria-live="polite"></ul>
    </div>
    <form id="alert-definition-editor" class="alert-definition-editor" hidden novalidate>
      <input type="hidden" id="alert-definition-id" />
      <label for="alert-definition-label">Alert label</label>
      <input id="alert-definition-label" name="label" type="text" required />
      <label for="alert-definition-description">Description</label>
      <textarea id="alert-definition-description" name="description" rows="3" placeholder="Explain what this alert checks"></textarea>
      <label for="alert-definition-logic">Logic</label>
      <textarea
        id="alert-definition-logic"
        name="logic"
        rows="14"
        spellcheck="false"
        placeholder="def run(data_store, helpers, definition):\n    return []"
      ></textarea>
      <p class="form-hint">
        Logic must define a <code>run(data_store, helpers, definition)</code> function and return a list of
        dictionaries with <code>type</code> and <code>message</code> keys. Use the helpers to normalise strings and
        format contacts.
      </p>
      <div class="form-actions">
        <button type="submit" class="primary">Save changes</button>
        <button type="button" class="danger" id="delete-alert-definition">Delete alert</button>
      </div>
    </form>
  </div>
  <div id="alert-definition-feedback" class="feedback" role="status" aria-live="polite"></div>
</section>

<section id="alert-guide-step" class="panel" aria-labelledby="alert-guide-heading">
  <h2 id="alert-guide-heading">Step 4 &mdash; Author advanced alerts</h2>
  <p>
    Use this reference to design new alert definitions programmatically. It describes the full data model that the
    alert engine exposes, every required field in an alert definition, validation rules, execution flow, and reusable
    helper utilities. With this guide and the existing definitions, an LLM can generate new logic without reading any
    other part of the codebase.
  </p>

  <article class="alert-guide">
    <h3 id="alert-guide-data-graph">1. Data graph available to alerts</h3>
    <p>
      All data lives in the in-memory <code>DataStore</code> instance that is refreshed after each CSV import. Entities are
      keyed by Salesforce IDs and normalised to stripped strings during import.
    </p>
    <ul>
      <li><code>accounts</code> &mdash; dictionary keyed by <code>Account.Id</code> with the raw account row, including the
        <code>Name</code> column.【F:app/data/data_store.py†L12-L31】</li>
      <li><code>contacts</code> &mdash; dictionary keyed by <code>Contact.Id</code>. Each stored contact retains
        <code>FirstName</code>, <code>LastName</code>, and <code>IndividualId</code>.【F:app/data/data_store.py†L12-L31】</li>
      <li><code>individuals</code> &mdash; dictionary keyed by <code>Individual.Id</code> with name attributes.【F:app/data/data_store.py†L12-L31】</li>
      <li><code>account_contact_relations</code> &mdash; list of relationship rows exposing <code>AccountId</code>,
        <code>ContactId</code>, and <code>Roles</code>.【F:app/data/data_store.py†L24-L32】</li>
      <li><code>contact_point_phones</code> and <code>contact_point_emails</code> &mdash; lists of touchpoint rows keyed by
        <code>ParentId</code> (an <code>IndividualId</code>).【F:app/data/data_store.py†L24-L32】</li>
    </ul>
    <p>
      The importer guarantees that records are trimmed and stored with consistent keys. Required columns for each
      entity are documented in <code>CSVImporter.ENTITY_FIELDS</code>.【F:app/services/importer.py†L10-L33】
    </p>

    <h4 id="alert-guide-indexes">Relationship indexes rebuilt on import</h4>
    <p>
      After every import, the store precomputes lookup tables to make alert logic faster and more expressive:
    </p>
    <ul>
      <li><code>account_to_contact_relations</code> &mdash; maps <code>AccountId</code> to its
        <code>AccountContactRelation</code> rows for quick per-account queries.【F:app/data/data_store.py†L34-L45】</li>
      <li><code>contact_to_individual_id</code> &mdash; maps <code>ContactId</code> to <code>IndividualId</code>, while
        <code>individual_to_contact_ids</code> stores the inverse for cross-contact comparisons by individual.【F:app/data/data_store.py†L45-L53】</li>
      <li><code>individual_to_phones</code> / <code>individual_to_emails</code> &mdash; gather all contact point rows for an
        individual, making it easy to aggregate phones and emails across linked contacts.【F:app/data/data_store.py†L55-L63】</li>
    </ul>
    <p>
      Convenience accessors provide enriched views:
    </p>
    <ul>
      <li><code>get_contacts_for_account(account_id)</code> returns copies of the contact rows augmented with a
        <code>_relation</code> key that exposes the originating <code>AccountContactRelation</code>.【F:app/data/data_store.py†L65-L75】</li>
      <li><code>get_individual_for_contact(contact_id)</code>, <code>get_phones_for_contact(contact_id)</code>, and
        <code>get_emails_for_contact(contact_id)</code> traverse the indexes above to deliver the linked record sets.【F:app/data/data_store.py†L77-L98】</li>
    </ul>

    <h3 id="alert-guide-definition-structure">2. Alert definition schema</h3>
    <p>
      Alert definitions live in <code>app/data/alert_definitions.json</code> under the top-level <code>alerts</code> array.
      Each entry must satisfy the validation rules enforced by the <code>AlertEngine</code>:
    </p>
    <ul>
      <li><code>id</code> (string, required) &mdash; stable identifier used for editing and ordering.【F:app/services/alert_engine.py†L33-L52】</li>
      <li><code>label</code> (string, required) &mdash; human-readable title surfaced in the UI and fallback alert type.【F:app/services/alert_engine.py†L33-L52】</li>
      <li><code>description</code> (string, optional but recommended) &mdash; appears in the configuration panel to describe the check.【F:app/data/alert_definitions.json†L1-L58】</li>
      <li><code>logic</code> (string, required) &mdash; Python source that defines <code>run(data_store, helpers, definition)</code>.
        The engine compiles this function with <code>exec</code> and rejects definitions without a callable named
        <code>run</code>.【F:app/services/alert_engine.py†L33-L52】</li>
    </ul>
    <p>
      When saved via the editor or API, definitions are persisted with the same structure by the
      <code>AlertDefinitionStore</code>.【F:app/services/alert_definition_store.py†L9-L33】
    </p>
    <pre><code>{
  "id": "unique_identifier",
  "label": "Readable alert title",
  "description": "Explains what the alert checks",
  "logic": "def run(data_store, helpers, definition):\n    alerts = []\n    # add alert dictionaries to alerts\n    return alerts"
}
</code></pre>

    <h3 id="alert-guide-execution">3. Execution lifecycle</h3>
    <ol>
      <li>The engine loads definitions in file order and compiles each <code>logic</code> string into a Python function.【F:app/services/alert_engine.py†L19-L52】</li>
      <li>It immediately calls <code>run(data_store, AlertHelpers(), definition)</code>. Any list of dictionaries returned is
        appended to the cumulative alert list.【F:app/services/alert_engine.py†L19-L41】</li>
      <li>Definitions that raise errors produce diagnostic alerts instead of interrupting the run, ensuring later
        definitions still execute.【F:app/services/alert_engine.py†L41-L49】</li>
      <li>Each alert dictionary must include at least a <code>type</code> and <code>message</code> string. Additional keys are
        preserved and passed through to the client UI.</li>
    </ol>
    <p>
      Ordering matters: definitions run sequentially and can rely on deterministic sorting of their own outputs.
    </p>

    <h3 id="alert-guide-helpers">4. Helper utilities available during <code>run</code></h3>
    <p>
      Every execution receives a fresh <code>AlertHelpers</code> instance with methods for normalisation, duplicate
      detection, and formatting. These helpers make alert logic shorter and consistent:
    </p>
    <ul>
      <li><code>normalize(value)</code> &mdash; trim and lowercase strings for grouping keys.【F:app/services/alert_helpers.py†L8-L24】</li>
      <li><code>title_case(value)</code> &mdash; trim and title-case strings for human-readable output.【F:app/services/alert_helpers.py†L12-L19】</li>
      <li><code>format_contact_name(contact)</code> &mdash; prefer full name, fallback to ID when missing.【F:app/services/alert_helpers.py†L16-L24】</li>
      <li><code>collect_values(records, candidate_keys)</code> &mdash; extract the first populated key from each record to build
        de-duplicated lists.【F:app/services/alert_helpers.py†L26-L36】</li>
      <li><code>find_duplicates(values)</code> &mdash; case-insensitive duplicate detector returning the original strings.【F:app/services/alert_helpers.py†L38-L44】</li>
      <li><code>get_account_name(data_store, account_id)</code> &mdash; resolve an account name or fall back to the raw ID.【F:app/services/alert_helpers.py†L46-L48】</li>
    </ul>

    <h3 id="alert-guide-patterns">5. Patterns and extension tips</h3>
    <ul>
      <li><strong>Cross-object joins</strong>: combine <code>data_store.get_contacts_for_account(account_id)</code> with
        <code>get_individual_for_contact</code> to compare household-level data.</li>
      <li><strong>Touchpoint analysis</strong>: use <code>collect_values</code> on <code>get_phones_for_contact</code> or
        <code>get_emails_for_contact</code> to aggregate contact points across linked individuals.【F:app/data/data_store.py†L87-L98】【F:app/services/alert_helpers.py†L26-L44】</li>
      <li><strong>Scoped iterations</strong>: iterate <code>data_store.account_to_contact_relations.items()</code> when
        grouping by account, or <code>data_store.contacts.items()</code> for global scans.【F:app/data/data_store.py†L34-L75】</li>
      <li><strong>Metadata reuse</strong>: store reusable configuration on the definition itself (for example,
        thresholds or role allowlists) and read them inside <code>run</code> via <code>definition.get("options", {})</code>.</li>
      <li><strong>Error resilience</strong>: raise clear exceptions when configuration is invalid; the engine will surface
        them as alerts without halting subsequent checks.【F:app/services/alert_engine.py†L41-L49】</li>
    </ul>

    <h3 id="alert-guide-example">6. Example: configurable role blacklist</h3>
    <p>Copy this template to ban disallowed roles across every account:</p>
    <pre><code>{
  "id": "forbidden_role",
  "label": "Forbidden account role",
  "description": "Warns when contacts hold a role that violates policy.",
  "options": {"blocked_roles": ["former advisor", "inactive"]},
  "logic": "def run(data_store, helpers, definition):\n    alerts = []\n    blocked = {helpers.normalize(role) for role in definition.get('options', {}).get('blocked_roles', [])}\n    if not blocked:\n        return alerts\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role = helpers.normalize(relation.get('Roles'))\n            if role in blocked:\n                contact = data_store.contacts.get(relation.get('ContactId'))\n                alerts.append({\n                    'type': definition.get('label', 'Alert'),\n                    'message': f\"Account '{account_name}' lists {helpers.format_contact_name(contact)} as '{helpers.title_case(role)}', a forbidden role.\"\n                })\n    return alerts"
}
</code></pre>
    <p>
      Extend the <code>options</code> payload with any extra parameters your alert logic needs. Because the engine persists
      definitions verbatim, custom keys remain available on subsequent edits and executions.【F:app/services/alert_definition_store.py†L23-L27】
    </p>
  </article>
</section>
{% endblock %}
