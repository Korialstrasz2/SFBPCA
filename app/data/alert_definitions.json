{
  "alerts": [
    {
      "id": "duplicate_role_same_name_tax_id",
      "label": "Duplicati stesso ruolo e identificativi",
      "description": "Contatti con stesso ruolo, nome e codice fiscale o partita IVA duplicati sullo stesso account.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        grouped = {}\n        for relation in relations:\n            role_raw = relation.get(\"Roles\")\n            role_norm = helpers.normalize(role_raw)\n            if not role_norm or role_norm == excluded_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            first = helpers.normalize(contact.get(\"FirstName\"))\n            last = helpers.normalize(contact.get(\"LastName\"))\n            name_key = f\"{first} {last}\".strip()\n            if not name_key:\n                continue\n            entry = {\n                \"contact\": contact,\n                \"contact_id\": contact_id,\n                \"relation_id\": relation.get(\"Id\"),\n                \"individual_id\": contact.get(\"IndividualId\"),\n                \"fiscal_norm\": helpers.normalize(contact.get(\"FiscalCode__c\")),\n                \"fiscal_raw\": contact.get(\"FiscalCode__c\").strip() if isinstance(contact.get(\"FiscalCode__c\"), str) else contact.get(\"FiscalCode__c\"),\n                \"vat_norm\": helpers.normalize(contact.get(\"VATNumber__c\")),\n                \"vat_raw\": contact.get(\"VATNumber__c\").strip() if isinstance(contact.get(\"VATNumber__c\"), str) else contact.get(\"VATNumber__c\"),\n            }\n            grouped.setdefault((role_norm, name_key), []).append(entry)\n        for (role_norm, name_key), entries in grouped.items():\n            duplicates = []\n            fiscal_groups = {}\n            for entry in entries:\n                if entry[\"fiscal_norm\"]:\n                    fiscal_groups.setdefault(entry[\"fiscal_norm\"], []).append(entry)\n            for matches in fiscal_groups.values():\n                if len(matches) > 1:\n                    duplicates.append((\"codice fiscale\", matches[0][\"fiscal_raw\"], matches))\n            vat_groups = {}\n            for entry in entries:\n                if entry[\"vat_norm\"]:\n                    vat_groups.setdefault(entry[\"vat_norm\"], []).append(entry)\n            for matches in vat_groups.values():\n                if len(matches) > 1:\n                    duplicates.append((\"partita IVA\", matches[0][\"vat_raw\"], matches))\n            for label, value, matches in duplicates:\n                account_name = helpers.get_account_name(data_store, account_id)\n                role_label = helpers.title_case(role_norm)\n                contact_names = \", \".join(sorted({helpers.format_contact_name(entry[\"contact\"]) for entry in matches}))\n                contact_ids = {entry.get(\"contact_id\") for entry in matches if entry.get(\"contact_id\")}\n                relation_ids = {entry.get(\"relation_id\") for entry in matches if entry.get(\"relation_id\")}\n                individual_ids = {entry.get(\"individual_id\") for entry in matches if entry.get(\"individual_id\")}\n                alert_objects = {\"Account Id\": [account_id]} if account_id else {}\n                if contact_ids:\n                    alert_objects[\"Contact Ids\"] = sorted(contact_ids)\n                if relation_ids:\n                    alert_objects[\"Account Contact Relation Ids\"] = sorted(relation_ids)\n                if individual_ids:\n                    alert_objects[\"Individual Ids\"] = sorted(individual_ids)\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Account '{account_name}' ha più contatti ({contact_names}) con ruolo '{role_label}' e lo stesso {label}: {value}.\",\n                        \"objects\": alert_objects,\n                    }\n                )\n    return alerts\n"
    },
    {
      "id": "missing_role_on_relation",
      "label": "Contatti senza ruolo",
      "description": "Contatti collegati ad un account senza un ruolo valorizzato.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role_raw = relation.get(\"Roles\")\n            role_norm = helpers.normalize(role_raw)\n            if role_norm == excluded_role:\n                continue\n            has_role = False\n            if isinstance(role_raw, str):\n                has_role = bool(role_raw.strip())\n            else:\n                has_role = bool(role_raw)\n            if has_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            contact_name = helpers.format_contact_name(contact)\n            objects = {\"Account Id\": [account_id]} if account_id else {}\n            if contact_id:\n                objects[\"Contact Id\"] = [contact_id]\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                objects[\"Account Contact Relation Id\"] = [relation_id]\n            individual_id = contact.get(\"IndividualId\") if contact else None\n            if individual_id:\n                objects[\"Individual Id\"] = [individual_id]\n            alerts.append(\n                {\n                    \"type\": definition.get(\"label\", \"Alert\"),\n                    \"message\": f\"Il contatto {contact_name} collegato all'account '{account_name}' non ha un ruolo valorizzato.\",\n                    \"objects\": objects,\n                }\n            )\n    return alerts\n"
    },
    {
      "id": "contact_missing_phone_or_email",
      "label": "Contatti senza telefono o mail",
      "description": "Contatti che non hanno né telefono fisso/mobile né indirizzo e-mail valorizzati.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role_norm = helpers.normalize(relation.get(\"Roles\"))\n            if role_norm == excluded_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            values = [contact.get(\"MobilePhone\"), contact.get(\"HomePhone\"), contact.get(\"Email\")]\n            has_value = any(\n                (isinstance(value, str) and value.strip()) or (not isinstance(value, str) and value)\n                for value in values\n                if value is not None\n            )\n            if has_value:\n                continue\n            contact_name = helpers.format_contact_name(contact)\n            objects = {\"Account Id\": [account_id]} if account_id else {}\n            if contact_id:\n                objects[\"Contact Id\"] = [contact_id]\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                objects[\"Account Contact Relation Id\"] = [relation_id]\n            individual_id = contact.get(\"IndividualId\")\n            if individual_id:\n                objects[\"Individual Id\"] = [individual_id]\n            alerts.append(\n                {\n                    \"type\": definition.get(\"label\", \"Alert\"),\n                    \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' non ha telefono fisso/mobile né e-mail valorizzati.\",\n                    \"objects\": objects,\n                }\n            )\n    return alerts\n"
    },
    {
      "id": "same_name_different_roles",
      "label": "Contatti con nomi uguali e ruoli diversi",
      "description": "Contatti sullo stesso account con stesso nome ma ruoli differenti.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        grouped = {}\n        for relation in relations:\n            role_raw = relation.get(\"Roles\")\n            role_norm = helpers.normalize(role_raw)\n            if not role_norm or role_norm == excluded_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            first = helpers.normalize(contact.get(\"FirstName\"))\n            last = helpers.normalize(contact.get(\"LastName\"))\n            if not (first or last):\n                continue\n            key = (first, last)\n            bucket = grouped.setdefault(\n                key,\n                {\n                    \"roles\": set(),\n                    \"contact_ids\": set(),\n                    \"relation_ids\": set(),\n                    \"individual_ids\": set(),\n                },\n            )\n            bucket[\"roles\"].add(role_norm)\n            if contact_id:\n                bucket[\"contact_ids\"].add(contact_id)\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                bucket[\"relation_ids\"].add(relation_id)\n            individual_id = contact.get(\"IndividualId\")\n            if individual_id:\n                bucket[\"individual_ids\"].add(individual_id)\n        for (first, last), bucket in grouped.items():\n            if len(bucket[\"roles\"]) > 1:\n                account_name = helpers.get_account_name(data_store, account_id)\n                formatted_name = f\"{helpers.title_case(first)} {helpers.title_case(last)}\".strip()\n                role_list = \", \".join(sorted(helpers.title_case(role) for role in bucket[\"roles\"]))\n                objects = {\"Account Id\": [account_id]} if account_id else {}\n                if bucket[\"contact_ids\"]:\n                    objects[\"Contact Ids\"] = sorted(bucket[\"contact_ids\"])\n                if bucket[\"relation_ids\"]:\n                    objects[\"Account Contact Relation Ids\"] = sorted(bucket[\"relation_ids\"])\n                if bucket[\"individual_ids\"]:\n                    objects[\"Individual Ids\"] = sorted(bucket[\"individual_ids\"])\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Account '{account_name}' ha il contatto {formatted_name} con ruoli differenti: {role_list}.\",\n                        \"objects\": objects,\n                    }\n                )\n    return alerts\n"
    },
    {
      "id": "contact_phone_contactpoint_alignment",
      "label": "Telefono contatto non coerente",
      "description": "Verifica coerenza tra telefoni del contatto e i ContactPointPhone associati.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role_norm = helpers.normalize(relation.get(\"Roles\"))\n            if role_norm == excluded_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            phone_values = {}\n            for label, field in (\"mobile\", \"MobilePhone\"), (\"fisso\", \"HomePhone\"):\n                raw = contact.get(field)\n                if isinstance(raw, str) and raw.strip():\n                    phone_values[label] = {\n                        \"raw\": raw.strip(),\n                        \"norm\": helpers.normalize_phone(raw),\n                    }\n            cp_phones = data_store.get_phones_for_contact(contact_id)\n            cp_numbers = set()\n            cp_ids = {phone.get(\"Id\") for phone in cp_phones if phone.get(\"Id\")}\n            for phone in cp_phones:\n                candidate = phone.get(\"TelephoneNumber\") or phone.get(\"Phone\")\n                norm = helpers.normalize_phone(candidate)\n                if norm:\n                    cp_numbers.add(norm)\n            contact_has_phone = any(value[\"norm\"] for value in phone_values.values())\n            cp_has_phone = bool(cp_numbers)\n            contact_name = helpers.format_contact_name(contact)\n            objects = {\"Account Id\": [account_id]} if account_id else {}\n            if contact_id:\n                objects[\"Contact Id\"] = [contact_id]\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                objects[\"Account Contact Relation Id\"] = [relation_id]\n            individual_id = contact.get(\"IndividualId\")\n            if individual_id:\n                objects[\"Individual Id\"] = [individual_id]\n            if cp_ids:\n                objects[\"Contact Point Phone Ids\"] = sorted(cp_ids)\n            if contact_has_phone and not cp_has_phone:\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' ha telefono valorizzato ma nessun ContactPointPhone associato.\",\n                        \"objects\": objects,\n                    }\n                )\n                continue\n            if cp_has_phone and not contact_has_phone:\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' ha ContactPointPhone ma nessun telefono fisso o mobile valorizzato.\",\n                        \"objects\": objects,\n                    }\n                )\n                continue\n            missing = []\n            for label, value in phone_values.items():\n                if value[\"norm\"] and value[\"norm\"] not in cp_numbers:\n                    missing.append((label, value[\"raw\"]))\n            if missing:\n                descriptions = \", \".join(f\"{label}: {raw}\" for label, raw in missing)\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' ha telefoni non presenti nei ContactPointPhone: {descriptions}.\",\n                        \"objects\": objects,\n                    }\n                )\n    return alerts\n"
    },
    {
      "id": "contact_email_contactpoint_alignment",
      "label": "E-mail contatto non coerente",
      "description": "Verifica coerenza tra e-mail del contatto e i ContactPointEmail associati.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    excluded_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role_norm = helpers.normalize(relation.get(\"Roles\"))\n            if role_norm == excluded_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            email_raw = contact.get(\"Email\")\n            email_norm = helpers.normalize(email_raw)\n            cp_emails = data_store.get_emails_for_contact(contact_id)\n            cp_norms = set()\n            cp_ids = {email.get(\"Id\") for email in cp_emails if email.get(\"Id\")}\n            for email in cp_emails:\n                value = email.get(\"EmailAddress\") or email.get(\"Email\")\n                norm = helpers.normalize(value)\n                if norm:\n                    cp_norms.add(norm)\n            contact_has_email = bool(email_norm)\n            cp_has_email = bool(cp_norms)\n            contact_name = helpers.format_contact_name(contact)\n            objects = {\"Account Id\": [account_id]} if account_id else {}\n            if contact_id:\n                objects[\"Contact Id\"] = [contact_id]\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                objects[\"Account Contact Relation Id\"] = [relation_id]\n            individual_id = contact.get(\"IndividualId\")\n            if individual_id:\n                objects[\"Individual Id\"] = [individual_id]\n            if cp_ids:\n                objects[\"Contact Point Email Ids\"] = sorted(cp_ids)\n            if contact_has_email and not cp_has_email:\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' ha un'e-mail valorizzata ma nessun ContactPointEmail associato.\",\n                        \"objects\": objects,\n                    }\n                )\n                continue\n            if cp_has_email and not contact_has_email:\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' ha ContactPointEmail ma nessuna e-mail sul contatto.\",\n                        \"objects\": objects,\n                    }\n                )\n                continue\n            if contact_has_email and email_norm not in cp_norms:\n                alerts.append(\n                    {\n                        \"type\": definition.get(\"label\", \"Alert\"),\n                        \"message\": f\"L'e-mail del contatto {contact_name} dell'account '{account_name}' non coincide con i ContactPointEmail caricati.\",\n                        \"objects\": objects,\n                    }\n                )\n    return alerts\n"
    },
    {
      "id": "referente_sol_missing_sol_email",
      "label": "Referente SOL senza e-mail SOL",
      "description": "Contatti con ruolo Referente SOL-APP privi di ContactPointEmail con tipologia 'E-mail SOL'.",
      "logic": "\ndef run(data_store, helpers, definition):\n    alerts = []\n    target_role = helpers.normalize(\"Referente SOL-APP\")\n    for account_id, relations in data_store.account_to_contact_relations.items():\n        account_name = helpers.get_account_name(data_store, account_id)\n        for relation in relations:\n            role_norm = helpers.normalize(relation.get(\"Roles\"))\n            if role_norm != target_role:\n                continue\n            contact_id = relation.get(\"ContactId\")\n            contact = data_store.contacts.get(contact_id)\n            if not contact:\n                continue\n            cp_emails = data_store.get_emails_for_contact(contact_id)\n            has_sol_email = False\n            sol_label = helpers.normalize(\"E-mail SOL\")\n            cp_ids = {email.get(\"Id\") for email in cp_emails if email.get(\"Id\")}\n            for email in cp_emails:\n                type_norm = helpers.normalize(email.get(\"Type__c\"))\n                value = email.get(\"EmailAddress\") or email.get(\"Email\")\n                if type_norm == sol_label and isinstance(value, str) and value.strip():\n                    has_sol_email = True\n                    break\n            if has_sol_email:\n                continue\n            contact_name = helpers.format_contact_name(contact)\n            objects = {\"Account Id\": [account_id]} if account_id else {}\n            if contact_id:\n                objects[\"Contact Id\"] = [contact_id]\n            relation_id = relation.get(\"Id\")\n            if relation_id:\n                objects[\"Account Contact Relation Id\"] = [relation_id]\n            individual_id = contact.get(\"IndividualId\")\n            if individual_id:\n                objects[\"Individual Id\"] = [individual_id]\n            if cp_ids:\n                objects[\"Contact Point Email Ids\"] = sorted(cp_ids)\n            alerts.append(\n                {\n                    \"type\": definition.get(\"label\", \"Alert\"),\n                    \"message\": f\"Il contatto {contact_name} dell'account '{account_name}' con ruolo Referente SOL-APP non ha un ContactPointEmail di tipologia 'E-mail SOL'.\",\n                    \"objects\": objects,\n                }\n            )\n    return alerts\n"
    }
  ]
}